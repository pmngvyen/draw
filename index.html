<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Drawing App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: white;
        }
        #toolbar {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: row;
            gap: 8px;
            z-index: 10;
        }
        .tool-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .tool-btn:hover {
            background: #f5f5f5;
            border-color: #999;
        }
        .tool-btn.active {
            background: #e3f2fd;
            border-color: #2196F3;
        }
        .tool-btn svg {
            width: 22px;
            height: 22px;
            stroke: #333;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .separator {
            width: 1px;
            background: #ddd;
            margin: 0 2px;
        }
        #canvas {
            display: block;
            cursor: default;
            background: white;
        }
        #canvas.pen-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><circle cx="2" cy="2" r="2" fill="black"/></svg>') 2 2, auto;
        }
        #canvas.highlighter-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><circle cx="2" cy="2" r="2.5" fill="black" opacity="0.5"/></svg>') 2 2, auto;
        }
        #canvas.eraser-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><rect x="2" y="2" width="8" height="8" fill="none" stroke="black" stroke-width="1.5"/></svg>') 6 6, auto;
        }
        #canvas.text-cursor {
            cursor: text;
        }
        
        #textInput {
            position: fixed;
            border: 2px solid #2196F3;
            background: transparent;
            padding: 5px;
            font-family: Arial, sans-serif;
            outline: none;
            display: none;
            min-width: 50px;
            resize: none;
            overflow: hidden;
            z-index: 50;
            white-space: nowrap;
        }
        
        .text-handle {
            position: fixed;
            width: 20px;
            height: 20px;
            background: #2196F3;
            border: 2px solid white;
            border-radius: 50%;
            cursor: move;
            display: none;
            z-index: 51;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .font-select {
            width: 140px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .popup-menu {
            position: fixed;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            flex-direction: column;
            gap: 15px;
            z-index: 11;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease;
        }
        .popup-menu.show {
            opacity: 1;
            pointer-events: auto;
        }
        #penPopup {
            display: flex;
        }
        #highlighterPopup {
            display: flex;
        }
        
        #textPopup {
            display: flex;
        }
        
        #saveMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            display: none;
            flex-direction: column;
            gap: 15px;
            z-index: 100;
            min-width: 300px;
        }
        #saveMenu.show {
            display: flex;
        }
        .save-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 99;
        }
        .save-overlay.show {
            display: block;
        }
        .save-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .save-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .save-option-btn {
            padding: 12px 20px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .save-option-btn:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }
        .save-option-icon {
            width: 20px;
            height: 20px;
        }
        .save-option-icon svg {
            width: 100%;
            height: 100%;
            stroke: #333;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        
        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            color: black;
            padding: 20px 40px;
            border-radius: 12px;
            font-size: 18px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #notification.show {
            opacity: 1;
        }
        .popup-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .popup-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            text-transform: uppercase;
        }
        .color-grid {
            display: grid;
            grid-template-columns: repeat(4, 35px);
            gap: 8px;
        }
        .color-btn {
            width: 35px;
            height: 35px;
            border: 3px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .color-btn:hover {
            transform: scale(1.1);
        }
        .color-btn.active {
            border-color: #333;
            border-width: 3px;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333;
        }
        .color-picker-btn {
            background: linear-gradient(135deg, 
                red 0%, red 14.28%, 
                orange 14.28%, orange 28.56%, 
                yellow 28.56%, yellow 42.84%, 
                green 42.84%, green 57.12%, 
                blue 57.12%, blue 71.4%, 
                indigo 71.4%, indigo 85.68%, 
                violet 85.68%, violet 100%);
        }
        .color-picker-btn::after {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }
        input[type="color"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        .size-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        input[type="range"] {
            width: 140px;
        }
        .size-display {
            font-size: 14px;
            color: #333;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button class="tool-btn active" id="penBtn" title="Pen (click twice for settings)">
            <svg viewBox="0 0 24 24">
                <path d="M17 3l4 4L7 21l-4 1 1-4L17 3z"/>
            </svg>
        </button>
        <button class="tool-btn" id="highlighterBtn" title="Highlighter (click twice for settings)">
            <svg viewBox="0 0 24 24">
                <path d="M9 11L4 16l4 4 5-5M9 11l10-10 4 4-10 10"/>
                <path d="M14 6l4 4"/>
            </svg>
        </button>
        <button class="tool-btn" id="eraserBtn" title="Eraser (drag to erase strokes)">
            <svg viewBox="0 0 24 24">
                <path d="M7 21h10M2.5 16.5l5-5 7 7-5 5-7-7z"/>
                <path d="M8.5 10.5l6-6 7 7-6 6"/>
            </svg>
        </button>
        <button class="tool-btn" id="textBtn" title="Text (click to add text)">
            <svg viewBox="0 0 24 24">
                <polyline points="4 7 4 4 20 4 20 7"/>
                <line x1="9" y1="20" x2="15" y2="20"/>
                <line x1="12" y1="4" x2="12" y2="20"/>
            </svg>
        </button>
        <div class="separator"></div>
        <button class="tool-btn" id="undoBtn" title="Undo">
            <svg viewBox="0 0 24 24">
                <path d="M9 14L4 9l5-5"/>
                <path d="M20 20v-7a4 4 0 0 0-4-4H4"/>
            </svg>
        </button>
        <button class="tool-btn" id="redoBtn" title="Redo">
            <svg viewBox="0 0 24 24">
                <path d="M15 14l5-5-5-5"/>
                <path d="M4 20v-7a4 4 0 0 1 4-4h12"/>
            </svg>
        </button>
        <button class="tool-btn" id="clearBtn" title="Clear All">
            <svg viewBox="0 0 24 24">
                <polyline points="3 6 5 6 21 6"/>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
        </button>
        <div class="separator"></div>
        <button class="tool-btn" id="saveBtn" title="Save Drawing">
            <svg viewBox="0 0 24 24">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                <polyline points="17 21 17 13 7 13 7 21"/>
                <polyline points="7 3 7 8 15 8"/>
            </svg>
        </button>
    </div>

    <div id="penPopup" class="popup-menu">
        <div class="popup-section">
            <div class="popup-title">Color</div>
            <div class="color-grid">
                <div class="color-btn active" style="background: black;" data-color="black" data-menu="pen"></div>
                <div class="color-btn" style="background: #666;" data-color="#666" data-menu="pen"></div>
                <div class="color-btn" style="background: red;" data-color="red" data-menu="pen"></div>
                <div class="color-btn" style="background: #ff69b4;" data-color="#ff69b4" data-menu="pen"></div>
                <div class="color-btn" style="background: blue;" data-color="blue" data-menu="pen"></div>
                <div class="color-btn" style="background: #00bfff;" data-color="#00bfff" data-menu="pen"></div>
                <div class="color-btn" style="background: green;" data-color="green" data-menu="pen"></div>
                <div class="color-btn" style="background: #90ee90;" data-color="#90ee90" data-menu="pen"></div>
                <div class="color-btn" style="background: yellow;" data-color="yellow" data-menu="pen"></div>
                <div class="color-btn" style="background: orange;" data-color="orange" data-menu="pen"></div>
                <div class="color-btn" style="background: purple;" data-color="purple" data-menu="pen"></div>
                <div class="color-btn color-picker-btn" data-menu="pen" id="penColorPicker"></div>
            </div>
            <input type="color" id="penColorInput" value="#000000">
        </div>
        
        <div class="popup-section">
            <div class="popup-title">Brush Size</div>
            <div class="size-control">
                <input type="range" id="penSizeSlider" min="1" max="50" value="3">
                <div class="size-display"><span id="penSizeValue">3</span>px</div>
            </div>
        </div>
    </div>

    <div id="highlighterPopup" class="popup-menu">
        <div class="popup-section">
            <div class="popup-title">Color</div>
            <div class="color-grid">
                <div class="color-btn active" style="background: yellow;" data-color="yellow" data-menu="highlighter"></div>
                <div class="color-btn" style="background: #ffeb3b;" data-color="#ffeb3b" data-menu="highlighter"></div>
                <div class="color-btn" style="background: #90ee90;" data-color="#90ee90" data-menu="highlighter"></div>
                <div class="color-btn" style="background: #00bfff;" data-color="#00bfff" data-menu="highlighter"></div>
                <div class="color-btn" style="background: #ff69b4;" data-color="#ff69b4" data-menu="highlighter"></div>
                <div class="color-btn" style="background: orange;" data-color="orange" data-menu="highlighter"></div>
                <div class="color-btn" style="background: purple;" data-color="purple" data-menu="highlighter"></div>
                <div class="color-btn color-picker-btn" data-menu="highlighter" id="highlighterColorPicker"></div>
            </div>
            <input type="color" id="highlighterColorInput" value="#ffff00">
        </div>
        
        <div class="popup-section">
            <div class="popup-title">Thickness</div>
            <div class="size-control">
                <input type="range" id="highlighterSizeSlider" min="10" max="80" value="30">
                <div class="size-display"><span id="highlighterSizeValue">30</span>px</div>
            </div>
        </div>

        <div class="popup-section">
            <div class="popup-title">Opacity</div>
            <div class="size-control">
                <input type="range" id="highlighterOpacitySlider" min="10" max="100" value="30">
                <div class="size-display"><span id="highlighterOpacityValue">30</span>%</div>
            </div>
        </div>
    </div>

    <div class="save-overlay" id="saveOverlay"></div>
    
    <div id="notification">Copied!</div>
    
    <textarea id="textInput"></textarea>
    <div class="text-handle" id="textHandle"></div>
    
    <div id="saveMenu">
        <div class="save-title">Save Your Drawing</div>
        <div class="save-options">
            <button class="save-option-btn" id="savePNG">
                <span class="save-option-icon">
                    <svg viewBox="0 0 24 24">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <path d="M21 15l-5-5L5 21"/>
                    </svg>
                </span>
                <span>Save as PNG Image</span>
            </button>
            <button class="save-option-btn" id="saveJPG">
                <span class="save-option-icon">
                    <svg viewBox="0 0 24 24">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <path d="M21 15l-5-5L5 21"/>
                    </svg>
                </span>
                <span>Save as JPG Image</span>
            </button>
            <button class="save-option-btn" id="saveSVG">
                <span class="save-option-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                </span>
                <span>Save as SVG Vector</span>
            </button>
            <button class="save-option-btn" id="copyClipboard">
                <span class="save-option-icon">
                    <svg viewBox="0 0 24 24">
                        <rect x="9" y="9" width="13" height="13" rx="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                    </svg>
                </span>
                <span>Copy to Clipboard</span>
            </button>
        </div>
    </div>

    <div id="textPopup" class="popup-menu">
        <div class="popup-section">
            <div class="popup-title">Font</div>
            <select class="font-select" id="fontSelect">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Impact">Impact</option>
                <option value="Trebuchet MS">Trebuchet MS</option>
            </select>
        </div>
        
        <div class="popup-section">
            <div class="popup-title">Size</div>
            <div class="size-control">
                <input type="range" id="textSizeSlider" min="10" max="100" value="20">
                <div class="size-display"><span id="textSizeValue">20</span>px</div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let drawing = false;
        let currentTool = 'pen';
        let penColor = 'black';
        let penSize = 3;
        let highlighterColor = 'yellow';
        let highlighterSize = 30;
        let highlighterOpacity = 0.3;
        let currentStroke = [];
        let strokes = [];
        let redoStack = [];
        let lastPenClick = 0;
        let lastHighlighterClick = 0;
        let smoothingBuffer = [];
        let drawStartTime = 0;
        let isHolding = false;
        let straightLineTimeout = null;
        let textInput = document.getElementById('textInput');
        let textHandle = document.getElementById('textHandle');
        let isEditingText = false;
        let currentTextStroke = null;
        let isDraggingText = false;
        let textFont = 'Arial';
        let textSize = 20;
        let selectedTextIndex = -1;
        let isDraggingFinalizedText = false;
        let dragOffset = { x: 0, y: 0 };
        let lastTextClick = 0;
        let lastClickedTextIndex = -1;
        
        window.addEventListener('resize', () => {
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.putImageData(imgData, 0, 0);
        });
        
        function isPointInStroke(x, y, stroke) {
            // Much more generous threshold for instant eraser response
            const baseThreshold = stroke.tool === 'highlighter' ? stroke.size * 1.5 : stroke.size * 3;
            
            // Check against each point in the stroke
            for (let i = 0; i < stroke.points.length; i++) {
                const p = stroke.points[i];
                const distance = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                if (distance < baseThreshold) {
                    return true;
                }
            }
            
            // Also check between points for better coverage
            for (let i = 0; i < stroke.points.length - 1; i++) {
                const p1 = stroke.points[i];
                const p2 = stroke.points[i + 1];
                
                // Calculate distance from point to line segment
                const lineLength = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                if (lineLength === 0) continue;
                
                const t = Math.max(0, Math.min(1, ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / (lineLength * lineLength)));
                const projX = p1.x + t * (p2.x - p1.x);
                const projY = p1.y + t * (p2.y - p1.y);
                const distanceToLine = Math.sqrt((x - projX) ** 2 + (y - projY) ** 2);
                
                if (distanceToLine < baseThreshold) {
                    return true;
                }
            }
            
            return false;
        }
        
        function startDrawing(e) {
            if (currentTool === 'text') {
                const pos = getMousePos(e);
                const rect = canvas.getBoundingClientRect();
                const now = Date.now();
                
                // Check if clicking on existing text
                for (let i = strokes.length - 1; i >= 0; i--) {
                    const stroke = strokes[i];
                    if (stroke.tool === 'text') {
                        ctx.font = `${stroke.size}px ${stroke.font}`;
                        const textWidth = ctx.measureText(stroke.text).width;
                        const textHeight = stroke.size;
                        
                        if (pos.x >= stroke.x && pos.x <= stroke.x + textWidth &&
                            pos.y >= stroke.y && pos.y <= stroke.y + textHeight) {
                            
                            // Check for double-click
                            if (now - lastTextClick < 500 && lastClickedTextIndex === i) {
                                // Double-click detected - edit text
                                editExistingText(stroke, i, rect);
                                lastTextClick = 0;
                                lastClickedTextIndex = -1;
                                return;
                            }
                            
                            // Single click - prepare to drag
                            lastTextClick = now;
                            lastClickedTextIndex = i;
                            selectedTextIndex = i;
                            isDraggingFinalizedText = true;
                            dragOffset.x = pos.x - stroke.x;
                            dragOffset.y = pos.y - stroke.y;
                            return;
                        }
                    }
                }
                
                // No text clicked, place new text box
                lastTextClick = 0;
                lastClickedTextIndex = -1;
                placeTextBox(e, rect);
                return;
            }
            
            drawing = true;
            smoothingBuffer = [];
            drawStartTime = Date.now();
            isHolding = false;
            clearTimeout(straightLineTimeout);
            
            if (currentTool === 'eraser') {
                const pos = getMousePos(e);
                for (let i = strokes.length - 1; i >= 0; i--) {
                    if (isPointInStroke(pos.x, pos.y, strokes[i])) {
                        redoStack = [];
                        strokes.splice(i, 1);
                        redrawCanvas();
                        break;
                    }
                }
                return;
            }
            
            currentStroke = {
                tool: currentTool,
                color: currentTool === 'pen' ? penColor : highlighterColor,
                size: currentTool === 'pen' ? penSize : highlighterSize,
                opacity: currentTool === 'highlighter' ? highlighterOpacity : 1,
                points: []
            };
            const pos = getMousePos(e);
            smoothingBuffer.push(pos);
            currentStroke.points.push(pos);
            
            // Set timeout to detect if user is holding still
            straightLineTimeout = setTimeout(() => {
                if (drawing && currentStroke.points.length > 1) {
                    isHolding = true;
                    convertToStraightLine();
                }
            }, 400);
        }
        
        function draw(e) {
            if (!drawing && !isDraggingFinalizedText) return;
            
            const pos = getMousePos(e);
            
            // Handle dragging finalized text
            if (isDraggingFinalizedText && selectedTextIndex >= 0) {
                strokes[selectedTextIndex].x = pos.x - dragOffset.x;
                strokes[selectedTextIndex].y = pos.y - dragOffset.y;
                redrawCanvas();
                return;
            }
            
            // Reset timer if user is still moving
            if (!isHolding) {
                clearTimeout(straightLineTimeout);
                straightLineTimeout = setTimeout(() => {
                    if (drawing && currentStroke.points.length > 1) {
                        isHolding = true;
                        convertToStraightLine();
                    }
                }, 400);
            }
            
            if (currentTool === 'eraser') {
                // More aggressive erasing - check all strokes every frame
                let anyErased = false;
                for (let i = strokes.length - 1; i >= 0; i--) {
                    if (isPointInStroke(pos.x, pos.y, strokes[i])) {
                        strokes.splice(i, 1);
                        anyErased = true;
                    }
                }
                if (anyErased) {
                    redrawCanvas();
                }
                return;
            }
            
            if (isHolding) {
                // Update the endpoint of the straight line
                currentStroke.points[1] = pos;
                redrawCanvas();
                drawStroke(currentStroke);
                return;
            }
            
            // Add smoothing for pen tool only
            if (currentTool === 'pen') {
                smoothingBuffer.push(pos);
                
                // Keep buffer small for slight lag effect
                if (smoothingBuffer.length > 3) {
                    smoothingBuffer.shift();
                }
                
                // Calculate smoothed position (average of recent points)
                let smoothedX = 0;
                let smoothedY = 0;
                for (let i = 0; i < smoothingBuffer.length; i++) {
                    smoothedX += smoothingBuffer[i].x;
                    smoothedY += smoothingBuffer[i].y;
                }
                smoothedX /= smoothingBuffer.length;
                smoothedY /= smoothingBuffer.length;
                
                currentStroke.points.push({ x: smoothedX, y: smoothedY });
            } else {
                currentStroke.points.push(pos);
            }
            
            redrawCanvas();
            drawStroke(currentStroke);
        }
        
        function stopDrawing() {
            if (isDraggingFinalizedText) {
                // Only stop dragging if mouse actually moved
                isDraggingFinalizedText = false;
                selectedTextIndex = -1;
                return;
            }
            
            if (!drawing) return;
            drawing = false;
            clearTimeout(straightLineTimeout);
            
            if (currentTool !== 'eraser' && currentStroke.points.length > 0) {
                strokes.push(currentStroke);
                redoStack = [];
            }
            
            isHolding = false;
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX || e.touches[0].clientX) - rect.left,
                y: (e.clientY || e.touches[0].clientY) - rect.top
            };
        }
        
        function convertToStraightLine() {
            if (currentStroke.points.length < 2) return;
            
            const startPoint = currentStroke.points[0];
            const endPoint = currentStroke.points[currentStroke.points.length - 1];
            
            // Calculate distance
            const distance = Math.sqrt(
                Math.pow(endPoint.x - startPoint.x, 2) + 
                Math.pow(endPoint.y - startPoint.y, 2)
            );
            
            // Replace all points with just start and end for a perfect straight line
            currentStroke.points = [startPoint, endPoint];
            
            redrawCanvas();
            drawStroke(currentStroke);
        }
        
        function placeTextBox(e, rect) {
            const pos = getMousePos(e);
            
            textInput.style.left = (rect.left + pos.x) + 'px';
            textInput.style.top = (rect.top + pos.y) + 'px';
            textInput.style.display = 'block';
            textInput.style.fontSize = textSize + 'px';
            textInput.style.fontFamily = textFont;
            textInput.style.color = penColor;
            textInput.style.width = 'auto';
            textInput.style.height = 'auto';
            textInput.value = '';
            isEditingText = true;
            currentTextStroke = null;
            
            // Position handle
            textHandle.style.display = 'block';
            textHandle.style.left = (rect.left + pos.x - 10) + 'px';
            textHandle.style.top = (rect.top + pos.y - 10) + 'px';
            
            setTimeout(() => {
                textInput.focus();
            }, 10);
        }
        
        function editExistingText(stroke, index, rect) {
            textInput.style.left = (rect.left + stroke.x) + 'px';
            textInput.style.top = (rect.top + stroke.y) + 'px';
            textInput.style.display = 'block';
            textInput.style.fontSize = stroke.size + 'px';
            textInput.style.fontFamily = stroke.font;
            textInput.style.color = stroke.color;
            textInput.value = stroke.text;
            isEditingText = true;
            currentTextStroke = { stroke, index };
            
            // Position handle
            textHandle.style.display = 'block';
            textHandle.style.left = (rect.left + stroke.x - 10) + 'px';
            textHandle.style.top = (rect.top + stroke.y - 10) + 'px';
            
            setTimeout(() => {
                textInput.focus();
                textInput.select();
            }, 10);
        }
        
        function finalizeText() {
            if (!isEditingText || !textInput.value.trim()) {
                textInput.style.display = 'none';
                textHandle.style.display = 'none';
                isEditingText = false;
                currentTextStroke = null;
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = parseInt(textInput.style.left) - rect.left;
            const y = parseInt(textInput.style.top) - rect.top;
            
            if (currentTextStroke) {
                // Update existing text
                strokes[currentTextStroke.index] = {
                    tool: 'text',
                    color: textInput.style.color,
                    size: parseInt(textInput.style.fontSize),
                    font: textInput.style.fontFamily,
                    text: textInput.value,
                    x: x,
                    y: y
                };
            } else {
                // Create new text
                strokes.push({
                    tool: 'text',
                    color: penColor,
                    size: textSize,
                    font: textFont,
                    text: textInput.value,
                    x: x,
                    y: y
                });
                redoStack = [];
            }
            
            redrawCanvas();
            textInput.style.display = 'none';
            textHandle.style.display = 'none';
            textInput.value = '';
            isEditingText = false;
            currentTextStroke = null;
        }
        
        // Text dragging
        textHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            isDraggingText = true;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDraggingText && isEditingText) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - 10;
                const y = e.clientY - 10;
                
                textHandle.style.left = x + 'px';
                textHandle.style.top = y + 'px';
                textInput.style.left = (x + 10) + 'px';
                textInput.style.top = (y + 10) + 'px';
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDraggingText = false;
        });
        
        textInput.addEventListener('blur', finalizeText);
        textInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                finalizeText();
            } else if (e.key === 'Escape') {
                textInput.style.display = 'none';
                textInput.value = '';
                isEditingText = false;
            }
        });
        
        function drawStroke(stroke) {
            if (stroke.tool === 'text') {
                ctx.font = `${stroke.size}px ${stroke.font}`;
                ctx.fillStyle = stroke.color;
                ctx.textBaseline = 'top';
                ctx.fillText(stroke.text, stroke.x, stroke.y);
                return;
            }
            
            if (stroke.points.length < 2) return;
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = stroke.opacity;
            ctx.lineWidth = stroke.size;
            ctx.strokeStyle = stroke.color;
            
            ctx.beginPath();
            ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
            
            for (let i = 1; i < stroke.points.length - 1; i++) {
                const xc = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
                const yc = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
                ctx.quadraticCurveTo(stroke.points[i].x, stroke.points[i].y, xc, yc);
            }
            
            if (stroke.points.length > 1) {
                const lastPoint = stroke.points[stroke.points.length - 1];
                const secondLastPoint = stroke.points[stroke.points.length - 2];
                ctx.quadraticCurveTo(
                    secondLastPoint.x,
                    secondLastPoint.y,
                    lastPoint.x,
                    lastPoint.y
                );
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes.forEach(stroke => drawStroke(stroke));
        }
        
        function undo() {
            if (strokes.length > 0) {
                redoStack.push(strokes.pop());
                redrawCanvas();
            }
        }
        
        function redo() {
            if (redoStack.length > 0) {
                strokes.push(redoStack.pop());
                redrawCanvas();
            }
        }
        
        function clearCanvas() {
            strokes = [];
            redoStack = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function downloadImage(format) {
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `drawing_${timestamp}.${format}`;
            
            if (format === 'jpg' || format === 'jpeg') {
                // Create white background for JPG
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0);
                link.href = tempCanvas.toDataURL('image/jpeg', 0.95);
            } else {
                link.href = canvas.toDataURL('image/png');
            }
            
            link.click();
            closeSaveMenu();
        }
        
        function saveSVG() {
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}">`;
            svg += '<rect width="100%" height="100%" fill="white"/>';
            
            strokes.forEach(stroke => {
                if (stroke.points.length < 2) return;
                
                let pathData = `M ${stroke.points[0].x} ${stroke.points[0].y}`;
                
                for (let i = 1; i < stroke.points.length - 1; i++) {
                    const xc = (stroke.points[i].x + stroke.points[i + 1].x) / 2;
                    const yc = (stroke.points[i].y + stroke.points[i + 1].y) / 2;
                    pathData += ` Q ${stroke.points[i].x} ${stroke.points[i].y} ${xc} ${yc}`;
                }
                
                if (stroke.points.length > 1) {
                    const lastPoint = stroke.points[stroke.points.length - 1];
                    const secondLastPoint = stroke.points[stroke.points.length - 2];
                    pathData += ` Q ${secondLastPoint.x} ${secondLastPoint.y} ${lastPoint.x} ${lastPoint.y}`;
                }
                
                svg += `<path d="${pathData}" stroke="${stroke.color}" stroke-width="${stroke.size}" stroke-linecap="round" stroke-linejoin="round" fill="none" opacity="${stroke.opacity}"/>`;
            });
            
            svg += '</svg>';
            
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `drawing_${timestamp}.svg`;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
            closeSaveMenu();
        }
        
        function copyToClipboard() {
            canvas.toBlob(blob => {
                navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]).then(() => {
                    showNotification();
                    closeSaveMenu();
                }).catch(err => {
                    alert('Failed to copy to clipboard');
                });
            });
        }
        
        function showNotification() {
            const notification = document.getElementById('notification');
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 1000);
        }
        
        function showSaveMenu() {
            document.getElementById('saveMenu').classList.add('show');
            document.getElementById('saveOverlay').classList.add('show');
        }
        
        function closeSaveMenu() {
            document.getElementById('saveMenu').classList.remove('show');
            document.getElementById('saveOverlay').classList.remove('show');
        }
        
        function closeAllMenus() {
            document.getElementById('penPopup').classList.remove('show');
            document.getElementById('highlighterPopup').classList.remove('show');
            document.getElementById('textPopup').classList.remove('show');
        }
        
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrawing(e);
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });
        
        let hoverTimeout;
        
        function positionMenu(menuId, buttonId) {
            const menu = document.getElementById(menuId);
            const button = document.getElementById(buttonId);
            const buttonRect = button.getBoundingClientRect();
            const menuWidth = menu.offsetWidth;
            
            // Center menu horizontally with the button
            const centerOffset = buttonRect.left + (buttonRect.width / 2) - (menuWidth / 2);
            
            // Position above the toolbar
            menu.style.left = centerOffset + 'px';
            menu.style.bottom = (window.innerHeight - buttonRect.top + 10) + 'px';
            menu.style.top = 'auto';
        }
        
        function showPenMenu() {
            clearTimeout(hoverTimeout);
            positionMenu('penPopup', 'penBtn');
            document.getElementById('penPopup').classList.add('show');
            document.getElementById('highlighterPopup').classList.remove('show');
        }
        
        function showHighlighterMenu() {
            clearTimeout(hoverTimeout);
            positionMenu('highlighterPopup', 'highlighterBtn');
            document.getElementById('highlighterPopup').classList.add('show');
            document.getElementById('penPopup').classList.remove('show');
        }
        
        function switchToPen() {
            currentTool = 'pen';
            document.getElementById('penBtn').classList.add('active');
            document.getElementById('highlighterBtn').classList.remove('active');
            document.getElementById('eraserBtn').classList.remove('active');
            document.getElementById('textBtn').classList.remove('active');
            canvas.className = 'pen-cursor';
        }
        
        function switchToHighlighter() {
            currentTool = 'highlighter';
            document.getElementById('highlighterBtn').classList.add('active');
            document.getElementById('penBtn').classList.remove('active');
            document.getElementById('eraserBtn').classList.remove('active');
            document.getElementById('textBtn').classList.remove('active');
            canvas.className = 'highlighter-cursor';
        }
        
        function showTextMenu() {
            clearTimeout(hoverTimeout);
            positionMenu('textPopup', 'textBtn');
            document.getElementById('textPopup').classList.add('show');
            document.getElementById('penPopup').classList.remove('show');
            document.getElementById('highlighterPopup').classList.remove('show');
        }
        
        function switchToText() {
            currentTool = 'text';
            document.getElementById('textBtn').classList.add('active');
            document.getElementById('penBtn').classList.remove('active');
            document.getElementById('highlighterBtn').classList.remove('active');
            document.getElementById('eraserBtn').classList.remove('active');
            canvas.className = 'text-cursor';
        }
        
        function hideMenus() {
            hoverTimeout = setTimeout(() => {
                closeAllMenus();
            }, 100);
        }
        
        document.getElementById('penBtn').addEventListener('click', switchToPen);
        
        document.getElementById('penBtn').addEventListener('mouseenter', showPenMenu);
        document.getElementById('penBtn').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('penPopup').addEventListener('mouseenter', () => {
            clearTimeout(hoverTimeout);
        });
        document.getElementById('penPopup').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('highlighterBtn').addEventListener('click', switchToHighlighter);
        
        document.getElementById('highlighterBtn').addEventListener('mouseenter', showHighlighterMenu);
        document.getElementById('highlighterBtn').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('highlighterPopup').addEventListener('mouseenter', () => {
            clearTimeout(hoverTimeout);
        });
        document.getElementById('highlighterPopup').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('eraserBtn').addEventListener('click', () => {
            currentTool = 'eraser';
            document.getElementById('eraserBtn').classList.add('active');
            document.getElementById('penBtn').classList.remove('active');
            document.getElementById('highlighterBtn').classList.remove('active');
            document.getElementById('textBtn').classList.remove('active');
            canvas.className = 'eraser-cursor';
            closeAllMenus();
        });
        
        document.getElementById('textBtn').addEventListener('click', () => {
            currentTool = 'text';
            document.getElementById('textBtn').classList.add('active');
            document.getElementById('penBtn').classList.remove('active');
            document.getElementById('highlighterBtn').classList.remove('active');
            document.getElementById('eraserBtn').classList.remove('active');
            canvas.className = 'text-cursor';
            closeAllMenus();
        });
        
        document.getElementById('textBtn').addEventListener('mouseenter', showTextMenu);
        document.getElementById('textBtn').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('textPopup').addEventListener('mouseenter', () => {
            clearTimeout(hoverTimeout);
        });
        document.getElementById('textPopup').addEventListener('mouseleave', hideMenus);
        
        document.getElementById('fontSelect').addEventListener('change', (e) => {
            textFont = e.target.value;
            switchToText();
            if (isEditingText) {
                textInput.style.fontFamily = textFont;
            }
        });
        
        document.getElementById('textSizeSlider').addEventListener('input', (e) => {
            textSize = parseInt(e.target.value);
            switchToText();
            document.getElementById('textSizeValue').textContent = textSize;
            if (isEditingText) {
                textInput.style.fontSize = textSize + 'px';
            }
        });
        
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const menu = btn.dataset.menu;
                const color = btn.dataset.color;
                
                if (color) {
                    if (menu === 'pen') {
                        penColor = color;
                        switchToPen();
                        document.querySelectorAll('[data-menu="pen"]').forEach(b => b.classList.remove('active'));
                    } else {
                        highlighterColor = color;
                        switchToHighlighter();
                        document.querySelectorAll('[data-menu="highlighter"]').forEach(b => b.classList.remove('active'));
                    }
                    btn.classList.add('active');
                }
            });
        });
        
        document.getElementById('penColorPicker').addEventListener('click', () => {
            document.getElementById('penColorInput').click();
        });
        
        document.getElementById('penColorInput').addEventListener('input', (e) => {
            penColor = e.target.value;
            switchToPen();
            document.querySelectorAll('[data-menu="pen"]').forEach(b => b.classList.remove('active'));
            document.getElementById('penColorPicker').classList.add('active');
            document.getElementById('penColorPicker').style.background = penColor;
        });
        
        document.getElementById('highlighterColorPicker').addEventListener('click', () => {
            document.getElementById('highlighterColorInput').click();
        });
        
        document.getElementById('highlighterColorInput').addEventListener('input', (e) => {
            highlighterColor = e.target.value;
            switchToHighlighter();
            document.querySelectorAll('[data-menu="highlighter"]').forEach(b => b.classList.remove('active'));
            document.getElementById('highlighterColorPicker').classList.add('active');
            document.getElementById('highlighterColorPicker').style.background = highlighterColor;
        });
        
        document.getElementById('penSizeSlider').addEventListener('input', (e) => {
            penSize = parseInt(e.target.value);
            switchToPen();
            document.getElementById('penSizeValue').textContent = penSize;
        });
        
        document.getElementById('highlighterSizeSlider').addEventListener('input', (e) => {
            highlighterSize = parseInt(e.target.value);
            switchToHighlighter();
            document.getElementById('highlighterSizeValue').textContent = highlighterSize;
        });
        
        document.getElementById('highlighterOpacitySlider').addEventListener('input', (e) => {
            highlighterOpacity = parseInt(e.target.value) / 100;
            switchToHighlighter();
            document.getElementById('highlighterOpacityValue').textContent = e.target.value;
        });
        
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('clearBtn').addEventListener('click', clearCanvas);
        document.getElementById('saveBtn').addEventListener('click', showSaveMenu);
        
        document.getElementById('savePNG').addEventListener('click', () => downloadImage('png'));
        document.getElementById('saveJPG').addEventListener('click', () => downloadImage('jpg'));
        document.getElementById('saveSVG').addEventListener('click', saveSVG);
        document.getElementById('copyClipboard').addEventListener('click', copyToClipboard);
        document.getElementById('saveOverlay').addEventListener('click', closeSaveMenu);
        
        document.addEventListener('click', (e) => {
            const penPopup = document.getElementById('penPopup');
            const highlighterPopup = document.getElementById('highlighterPopup');
            const textPopup = document.getElementById('textPopup');
            const toolbar = document.getElementById('toolbar');
            
            if (!penPopup.contains(e.target) && 
                !highlighterPopup.contains(e.target) && 
                !textPopup.contains(e.target) &&
                !toolbar.contains(e.target)) {
                closeAllMenus();
            }
        });
        
        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check for Cmd (Mac) or Ctrl (Windows/Linux)
            if (e.metaKey || e.ctrlKey) {
                if (e.shiftKey && e.key.toLowerCase() === 'z') {
                    // Cmd/Ctrl + Shift + Z = Redo
                    e.preventDefault();
                    redo();
                } else if (e.key.toLowerCase() === 'z') {
                    // Cmd/Ctrl + Z = Undo
                    e.preventDefault();
                    undo();
                }
            }
        });
    </script>
</body>
</html>
